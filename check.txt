- 프로그램은 양의 정수 수열을 인수로 사용할 수 있어야 함
- 프로그램은 병합-삽입 정렬 알고리즘을 사용하여 양의 정수 시퀀스를 정렬해야 함
-포든존슨 알고리즘 사용해야함

-프로그램 실행 중에 오류가 발생하면 표준 오류에 오류 메시지가 표시되어야 합니다.(standard error)
- 이 연습의 유효성을 검사하려면 코드에서 최소 두 개의 서로 다른 컨테이너를 사용해야 합니다. 
- 프로그램은 최소 3000개의 서로 다른 정수를 처리할 수 있어야 합니다.

다음은 표준 출력에 한 줄씩 표시해야 하는 정보에 대한 몇 가지 추가 지침입니다:
- 첫 번째 줄에는 명시적인 텍스트와 정렬되지 않은 양의 정수 시퀀스를 표시해야 합니다.
- 두 번째 줄에는 명시적인 텍스트와 정렬된 양의 정수 시퀀스를 표시해야 합니다.
- 세 번째 줄에는 알고리즘에 걸린 시간을 나타내는 명시적 메시지를 표시하고 양수 정수를 정렬하는 데 사용된 첫 번째 컨테이너를 지정해야 합니다.
- 마지막 줄에는 양의 정수 시퀀스를 정렬하는 데 사용된 두 번째 컨테이너를 지정하여 알고리즘에서 사용한 시간을 나타내는 명시적인 텍스트를 표시해야 합니다.
분류를 수행하는 데 사용되는 시간 표시 형식은 자유지만, 
선택한 정밀도는 사용된 두 컨테이너의 차이를 명확하게 볼 수 있어야 합니다.


포드-존슨 병합 삽입 알고리즘(Ford-Johnson Algorithm)
알고리즘 개요
포드-존슨 알고리즘은 레스터 포드 주니어 와 셀머 존슨 이 개발한 정렬 알고리즘으로, 병합과 삽입의 장점을 결합하여
이론적으로 최소 비교 횟수에 가장 근접한 성능을 보입니다.

21개 요소 정렬 예시

a1 → a2 → a3 → a4 → a5 → a6 → a7 → a8 → a9 → a10
↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓    ↓
b1   b2   b3   b4   b5   b6   b7   b8   b9   b10   [홀수요소]


알고리즘의 핵심 아이디어
1. 페어링 전략
요소들을 쌍으로 묶어 더 큰 요소들을 먼저 정렬
이렇게 하면 각 작은 요소의 상한(upper bound)이 결정됨
2. 최적 삽입 순서
왜 특별한 순서인가?
각 요소를 삽입할 때 필요한 비교 횟수를 최소화
이미 삽입된 요소들이 제공하는 정보를 최대한 활용
wk 수열에 따라 계산된 최적 순서
3. 이진 탐색 활용
각 요소를 주 체인에 삽입할 때 이진 탐색 사용
보장된 상한선 내에서만 탐색하므로 비교 횟수 최소화

수학적 기반(186페이지)
F(n) 공식
F(n) - F(n-1) = ⌊lg(3n/4)⌋

 최적성 증명 :
S(n) = ⌈lg n!⌉ = F(n) for n = 1, ..., 11, 20, 21

즉, 이 범위의 n에서 포드-존슨 알고리즘은 이론적 최적값을 달성합니다.

알고리즘의 의의
  장점:
1. 이론적 최적성: 작은 n에서 최소 비교 횟수 달성
2. 수학적 엄밀성: 정보 이론에 기반한 설계
3. 효율성: O(n log n)이지만 상수가 매우 작음
  단점:
1. 구현 복잡성: 매우 복잡한 로직과 순서 관리
2. 실용성 제한: 작은 데이터셋에서만 의미있는 개선
3. 메모리 오버헤드: 복잡한 자료구조 필요
    
vector<in>fordJohnsonsort(vector<int>& arr)    
    // 1. 쌍별 비교 및 분리
    // 2. 더 큰 요소들 정렬 (재귀적으로 Ford-Johnson 사용)
    // 3. 주 체인 구성
    // 4. wk 수열에 따른 최적 순서로 삽입
    // 5. 각 삽입 시 이진 탐색 사용





단계별 플랜
1.프로젝트 구조 설계 및 기본 파일 생성 (main.cpp, Makefile, 헤더 파일들)
2.입력 파싱 및 유효성 검사 구현 (양의 정수, 중복 처리, 에러 핸들링)
3.Ford-Johnson 알고리즘 핵심 로직 구현 (쌍별 비교, wk 수열, 삽입 순서)
4.std::vector를 사용한 Ford-Johnson 구현 및 최적화
5.std::deque를 사용한 Ford-Johnson 구현 및 성능 비교
6.C++98 호환 시간 측정 시스템 구현 (gettimeofday 또는 clock 사용)
7.요구사항에 맞는 출력 형식 구현 및 테스트
8.3000개 요소 처리 최적화 및 성능 테스트

성능 특성 비교가 목적:
std::vector의 특징:
- 연속된 메모리 배치 → 캐시 친화적
- 랜덤 액세스 O(1) → 이진 탐색에 유리
- 중간 삽입 O(n) → 요소들을 이동해야 함
- 메모리 재할당 가능성
std::deque의 특징:
- 블록 단위 메모리 → 덜 연속적
- 랜덤 액세스 O(1) → 하지만 vector보다 느림
- 양 끝 삽입/삭제 O(1) → 매우 빠름
- 중간 삽입 여전히 O(n)


전체 요약 프로세스 (코딩 흐름)
pair 묶기 및 작은값-큰값 식별/저장

큰값 리스트 정렬 (재귀적으로 repeat)

pend_chain을 Jacobsthal 순서로 블록 단위 역순 분할 → 해당 구간별로 반복:

각 작은 값을 짝의 큰값 앞 공간에서만 이진탐색 후 main_chain에 삽입

홀수 원소는 마지막에 main_chain 전체에서 이진탐색 삽입
------------
7.19 해야할일

Jacobsthal 수열 기반 삽입 순서	 ❗	get_jacobsthal_order() 구현 후 삽입 순서 적용
홀수 입력 _odd_element 처리	    ❗	삽입이 아닌, 나중에 이진삽입 방식으로 바꾸기
출력 정리 (Before / After 정렬)	❗	결과 확인을 위해 출력 포맷 추가하기
시간 측정	                     ❗	처리 시간 측정 ⏱

jacobsthal_sequence()	      ❌	단순 placeholder, 실제 Jacobsthal 수열 계산 X
Jacobsthal 순서 기반 삽입   	❌	insert 함수에서 Jacob 순서 적용 안 됨
Jacobsthal 수열 생성 함수   	❌	직접 get_jacobsthal_order() 만드는 게 필요
insert_small_values() 완료	⚠️	현재 i = 0~n 순서로 삽입 중, Jacob 적용 필요